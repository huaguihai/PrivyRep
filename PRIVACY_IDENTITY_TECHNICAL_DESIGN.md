# PrivyRep - æŠ€æœ¯æ–¹æ¡ˆè®¾è®¡ä¹¦

## 1. ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

### 1.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Frontend (Vite + React)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Dashboard  â”‚  â”‚ Verification â”‚  â”‚ Credentials  â”‚      â”‚
â”‚  â”‚   Component  â”‚  â”‚   Component  â”‚  â”‚  Component   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                          â”‚                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚    FHE Service (@zama-fhe/relayer-sdk)      â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                    RainbowKit + Wagmi
                          â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                 â”‚                 â”‚
        â–¼                 â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Identity     â”‚  â”‚ Reputation   â”‚  â”‚ Verification â”‚
â”‚ Proof        â”‚â—„â”€â”¤ Score        â”‚â—„â”€â”¤ Service      â”‚
â”‚ Contract     â”‚  â”‚ Contract     â”‚  â”‚ Contract     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                 â”‚                 â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                    FHEVM Network
                         â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚                 â”‚
                â–¼                 â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ FHE Gateway  â”‚  â”‚ Zama Oracle  â”‚
        â”‚ (Encryption) â”‚  â”‚ (Decryption) â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æŠ€æœ¯æ ˆé€‰å‹

#### Frontend
- **æ¡†æ¶**: Vite 6.0 + React 18 + TypeScript 5.x
- **æ ·å¼**: TailwindCSS 3.x
- **é’±åŒ…**: RainbowKit + Wagmi v2
- **FHE SDK**: @zama-fhe/relayer-sdk@0.2.0
- **çŠ¶æ€ç®¡ç†**: Zustand (è½»é‡çº§)
- **è·¯ç”±**: React Router v6

#### Smart Contracts
- **è¯­è¨€**: Solidity ^0.8.24
- **FHE åº“**: fhevm-solidity
- **æ¡†æ¶**: Hardhat
- **ç½‘ç»œ**: Sepolia Testnet (å¼€å‘) â†’ Zama Devnet (ç”Ÿäº§)

#### Infrastructure
- **RPC**: Multiple fallbacks (Alchemy, PublicNode, BlastAPI)
- **Gateway**: https://gateway.sepolia.zama.ai (chainId: 55815)
- **Oracle**: Zama Oracle (å¼‚æ­¥è§£å¯†)

---

## 2. æ™ºèƒ½åˆçº¦è®¾è®¡

### 2.1 åˆçº¦æ¶æ„

```
IdentityProofManager (ä¸»åˆçº¦)
    â”œâ”€â”€ ReputationScore (å£°èª‰åˆ†æ•°)
    â”œâ”€â”€ VerificationService (éªŒè¯æœåŠ¡)
    â””â”€â”€ CredentialNFT (è¯ä¹¦ SBT)
```

### 2.1.1 FHEVM ç±»å‹ç³»ç»Ÿå…³é”®ç‚¹ â­

**é—®é¢˜èƒŒæ™¯ï¼š**
åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œå¦‚æœåˆçº¦å‡½æ•°å‚æ•°ä½¿ç”¨é”™è¯¯çš„ç±»å‹ï¼ˆå¦‚ `bytes32`ï¼‰ï¼Œä¼šå¯¼è‡´é’±åŒ…ç­¾åæ—¶æ˜¾ç¤º"æœªçŸ¥äº¤æ˜“ç±»å‹"å’Œgasä¼°ç®—å¤±è´¥ã€‚

**âœ… æ­£ç¡®çš„ FHEVM ç±»å‹ä½¿ç”¨æ–¹å¼ï¼ˆå‚è€ƒ Zamabeliefï¼‰**

#### 1. å¯¼å…¥æ­£ç¡®çš„ç±»å‹

```solidity
// âŒ é”™è¯¯åšæ³•ï¼šä½¿ç”¨æ—§ç‰ˆæœ¬çš„å¯¼å…¥æ–¹å¼
import "@fhevm/solidity/lib/FHE.sol";
import "encrypted-types/EncryptedTypes.sol";

// âœ… æ­£ç¡®åšæ³•ï¼šä» @fhevm/solidity å¯¼å…¥æ‰€æœ‰å¿…éœ€ç±»å‹
import { FHE, externalEuint32, euint32 } from "@fhevm/solidity/lib/FHE.sol";
import { SepoliaConfig } from "@fhevm/solidity/config/ZamaConfig.sol";
```

#### 2. ç»§æ‰¿ SepoliaConfig

```solidity
// âŒ é”™è¯¯åšæ³•ï¼šä¸ç»§æ‰¿åŸºç±»
contract IdentityProofManager {
    // ...
}

// âœ… æ­£ç¡®åšæ³•ï¼šç»§æ‰¿ SepoliaConfigï¼ˆZamabelief çš„åšæ³•ï¼‰
contract IdentityProofManager is SepoliaConfig {
    // ...
}
```

#### 3. å‡½æ•°å‚æ•°ä½¿ç”¨ externalEuint* ç±»å‹

```solidity
// âŒ é”™è¯¯åšæ³•ï¼šä½¿ç”¨ bytes32 ç±»å‹
function registerIdentity(
    bytes32 encryptedAsset,      // âŒ é’±åŒ…æ— æ³•è¯†åˆ«
    bytes32 encryptedNFT,
    bytes32 encryptedAge,
    bytes32 encryptedTx,
    bytes calldata inputProof
) external {
    // éœ€è¦é¢å¤–çš„ wrap æ“ä½œ
    euint32 asset = FHE.fromExternal(externalEuint32.wrap(encryptedAsset), inputProof);
}

// âœ… æ­£ç¡®åšæ³•ï¼šä½¿ç”¨ externalEuint32 ç±»å‹ï¼ˆZamabelief çš„åšæ³•ï¼‰
function registerIdentity(
    externalEuint32 encryptedAsset,  // âœ… é’±åŒ…æ­£å¸¸è¯†åˆ«
    externalEuint32 encryptedNFT,
    externalEuint32 encryptedAge,
    externalEuint32 encryptedTx,
    bytes calldata inputProof
) external {
    // ç›´æ¥ä½¿ç”¨ï¼Œæ— éœ€ wrap
    euint32 asset = FHE.fromExternal(encryptedAsset, inputProof);
}
```

#### 4. æƒé™ç®¡ç†ï¼šFHE.allow å’Œ FHE.allowThis

```solidity
// âœ… æ­£ç¡®åšæ³•ï¼šåŒæ—¶æˆæƒç”¨æˆ·å’Œåˆçº¦è‡ªèº«
euint32 asset = FHE.fromExternal(encryptedAsset, inputProof);

// å…è®¸ç”¨æˆ·è®¿é—®ï¼ˆç”¨äºåç»­æ›´æ–°æ“ä½œï¼‰
FHE.allow(asset, msg.sender);

// å…è®¸åˆçº¦è‡ªèº«è®¿é—®ï¼ˆç”¨äº FHE è®¡ç®—ï¼‰
FHE.allowThis(asset);
```

#### 5. ğŸ”¥ FHE æƒé™è®¾ç½®çš„æ‰§è¡Œé¡ºåºï¼ˆå…³é”®é—®é¢˜ï¼ï¼‰

**é—®é¢˜ç—‡çŠ¶ï¼š**
- é’±åŒ…æ˜¾ç¤º"ç¬¬ä¸‰æ–¹åˆçº¦æ‰§è¡Œå¤±è´¥"
- é’±åŒ…æ˜¾ç¤º"æœªçŸ¥äº¤æ˜“ç±»å‹"
- Gas ä¼°ç®—å¤±è´¥
- ç­¾åå¤±è´¥

**æ ¹æœ¬åŸå› ï¼š** FHE æƒé™ç®¡ç†å‡½æ•°çš„è°ƒç”¨é¡ºåºé”™è¯¯ï¼

**âŒ é”™è¯¯çš„æ‰§è¡Œé¡ºåºï¼ˆå¯¼è‡´é’±åŒ…ç­¾åå¤±è´¥ï¼‰ï¼š**

```solidity
function registerIdentity(
    externalEuint32 encryptedAsset,
    externalEuint32 encryptedNFT,
    externalEuint32 encryptedAge,
    externalEuint32 encryptedTx,
    bytes calldata inputProof
) external {
    // Step 1: è½¬æ¢å¤–éƒ¨åŠ å¯†è¾“å…¥
    euint32 asset = FHE.fromExternal(encryptedAsset, inputProof);
    euint32 nft = FHE.fromExternal(encryptedNFT, inputProof);
    euint32 age = FHE.fromExternal(encryptedAge, inputProof);
    euint32 tx = FHE.fromExternal(encryptedTx, inputProof);

    // âŒ Step 2: å…ˆè®¾ç½®æƒé™ï¼ˆé”™è¯¯ï¼ï¼‰
    FHE.allow(asset, msg.sender);
    FHE.allow(nft, msg.sender);
    FHE.allow(age, msg.sender);
    FHE.allow(tx, msg.sender);

    FHE.allowThis(asset);
    FHE.allowThis(nft);
    FHE.allowThis(age);
    FHE.allowThis(tx);

    // âŒ Step 3: åå­˜å‚¨æ•°æ®ï¼ˆè¿™æ˜¯é”™è¯¯çš„é¡ºåºï¼ï¼‰
    identities[msg.sender] = EncryptedIdentity({
        assetBalance: asset,
        nftCount: nft,
        accountAge: age,
        txCount: tx,
        exists: true,
        registeredAt: block.timestamp
    });

    hasRegistered[msg.sender] = true;
}
```

**âœ… æ­£ç¡®çš„æ‰§è¡Œé¡ºåºï¼ˆå‚è€ƒ Zama å®˜æ–¹å®ç°ï¼‰ï¼š**

```solidity
function registerIdentity(
    externalEuint32 encryptedAsset,
    externalEuint32 encryptedNFT,
    externalEuint32 encryptedAge,
    externalEuint32 encryptedTx,
    bytes calldata inputProof
) external {
    // âœ… Step 1: è½¬æ¢å¤–éƒ¨åŠ å¯†è¾“å…¥
    euint32 asset = FHE.fromExternal(encryptedAsset, inputProof);
    euint32 nft = FHE.fromExternal(encryptedNFT, inputProof);
    euint32 age = FHE.fromExternal(encryptedAge, inputProof);
    euint32 tx = FHE.fromExternal(encryptedTx, inputProof);

    // âœ… Step 2: å…ˆå­˜å‚¨æ•°æ®åˆ°çŠ¶æ€å˜é‡ï¼ˆå…³é”®ï¼å¿…é¡»å…ˆå­˜å‚¨ï¼ï¼‰
    identities[msg.sender] = EncryptedIdentity({
        assetBalance: asset,
        nftCount: nft,
        accountAge: age,
        txCount: tx,
        exists: true,
        registeredAt: block.timestamp
    });

    hasRegistered[msg.sender] = true;

    // âœ… Step 3: åè®¾ç½®æƒé™ï¼ˆå…³é”®ï¼å¿…é¡»åœ¨å­˜å‚¨ä¹‹åï¼ï¼‰
    // æƒé™é¡ºåºï¼šå…ˆ allowThisï¼ˆåˆçº¦è‡ªå·±ï¼‰ï¼Œå allowï¼ˆç”¨æˆ·ï¼‰
    FHE.allowThis(asset);
    FHE.allow(asset, msg.sender);

    FHE.allowThis(nft);
    FHE.allow(nft, msg.sender);

    FHE.allowThis(age);
    FHE.allow(age, msg.sender);

    FHE.allowThis(tx);
    FHE.allow(tx, msg.sender);
}
```

**æ‰§è¡Œé¡ºåºè§„åˆ™æ€»ç»“ï¼š**

1. **è½¬æ¢** â†’ **å­˜å‚¨** â†’ **æˆæƒ** ï¼ˆå¿…é¡»æŒ‰ç…§è¿™ä¸ªé¡ºåºï¼ï¼‰
2. æƒé™è®¾ç½®å¿…é¡»åœ¨æ•°æ®å­˜å‚¨åˆ°çŠ¶æ€å˜é‡**ä¹‹å**
3. æ¯ä¸ªåŠ å¯†å€¼çš„æƒé™è®¾ç½®é¡ºåºï¼šå…ˆ `allowThis`ï¼Œå `allow(user)`

**æŠ€æœ¯åŸç†ï¼š**

FHEVM çš„æƒé™ç³»ç»Ÿè¦æ±‚ï¼š
- åŠ å¯†å€¼å¿…é¡»å…ˆç»‘å®šåˆ°å…·ä½“çš„å­˜å‚¨ä½ç½®ï¼ˆstorage slotï¼‰
- åªæœ‰å­˜å‚¨åï¼ŒFHEVM æ‰èƒ½æ­£ç¡®è¿½è¸ªåŠ å¯†å€¼çš„è®¿é—®æƒé™
- å¦‚æœåœ¨å­˜å‚¨å‰è®¾ç½®æƒé™ï¼Œæƒé™ä¿¡æ¯ä¼šä¸¢å¤±æˆ–ç»‘å®šå¤±è´¥

**å‚è€ƒå®ç°ï¼š**
- Zama å®˜æ–¹ç¤ºä¾‹ï¼š`fhevm-contracts/EncryptedERC20.sol`
- Zama å®˜æ–¹ç¤ºä¾‹ï¼š`fhevm-contracts/ConfidentialGovernorAlpha.sol`
- Zamabelief é¡¹ç›®ï¼š`contracts/BeliefMarket.sol`

**å…³é”®åŸå› ï¼š**

1. **ç±»å‹è¯†åˆ«**ï¼š`externalEuint32` æ˜¯ FHEVM å®šä¹‰çš„ç‰¹æ®Šç±»å‹ï¼Œé’±åŒ…å¯ä»¥æ­£ç¡®è¯†åˆ«å’Œåºåˆ—åŒ–
2. **ABI å…¼å®¹æ€§**ï¼šä½¿ç”¨æ­£ç¡®çš„ç±»å‹åï¼ŒABI ä¸­çš„å‡½æ•°ç­¾åæ‰èƒ½è¢«é’±åŒ…æ­£ç¡®è§£æ
3. **Gas ä¼°ç®—**ï¼šæ­£ç¡®çš„ç±»å‹å¯ä»¥è®©é’±åŒ…å‡†ç¡®ä¼°ç®— FHE æ“ä½œæ‰€éœ€çš„ gas
4. **é…ç½®ç»§æ‰¿**ï¼š`SepoliaConfig` åŒ…å«äº†ç½‘ç»œç‰¹å®šçš„é…ç½®ï¼ˆGatewayåœ°å€ã€Oracleåœ°å€ç­‰ï¼‰

**æŠ€æœ¯å¯¹æ¯”ï¼š**

| æ–¹æ¡ˆ | é’±åŒ…è¯†åˆ« | Gasä¼°ç®— | å¼€å‘å¤æ‚åº¦ |
|------|---------|--------|-----------|
| bytes32 + wrap | âŒ å¤±è´¥ | âŒ å¤±è´¥ | ğŸ”´ é«˜ï¼ˆéœ€è¦ wrapï¼‰ |
| externalEuint* | âœ… æˆåŠŸ | âœ… æˆåŠŸ | ğŸŸ¢ ä½ï¼ˆç›´æ¥ä½¿ç”¨ï¼‰ |

**å‚è€ƒå®ç°ï¼š**
- Zamabelief é¡¹ç›®ï¼š`contracts/BeliefMarket.sol`
- ä½¿ç”¨ `externalEuint64` ç±»å‹çš„ vote å‡½æ•°
- å®˜æ–¹æ–‡æ¡£ï¼šhttps://docs.zama.ai/fhevm

### 2.2 æ ¸å¿ƒåˆçº¦è¯¦è§£

#### 2.2.1 IdentityProofManager.sol

**èŒè´£**: ç®¡ç†ç”¨æˆ·çš„åŠ å¯†èº«ä»½è¯æ˜

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "fhevm/lib/TFHE.sol";
import "fhevm/gateway/GatewayCaller.sol";

contract IdentityProofManager is GatewayCaller {
    // ç”¨æˆ·èº«ä»½æ•°æ®ï¼ˆåŠ å¯†å­˜å‚¨ï¼‰
    struct EncryptedIdentity {
        euint32 assetBalance;      // åŠ å¯†èµ„äº§ä½™é¢
        euint32 nftCount;          // åŠ å¯† NFT æ•°é‡
        euint32 accountAge;        // åŠ å¯†è´¦æˆ·å¹´é¾„ï¼ˆå¤©ï¼‰
        euint32 txCount;           // åŠ å¯†äº¤æ˜“æ¬¡æ•°
        bool exists;               // æ˜¯å¦å·²æ³¨å†Œ
    }

    mapping(address => EncryptedIdentity) private identities;
    mapping(address => bool) public hasRegistered;

    event IdentityRegistered(address indexed user);
    event ProofSubmitted(address indexed user, string proofType);

    // ç”¨æˆ·æ³¨å†Œèº«ä»½ï¼ˆæäº¤åŠ å¯†æ•°æ®ï¼‰
    function registerIdentity(
        bytes calldata encryptedAsset,
        bytes calldata encryptedNFT,
        bytes calldata encryptedAge,
        bytes calldata encryptedTx,
        bytes calldata inputProof
    ) external {
        require(!hasRegistered[msg.sender], "Already registered");

        // è§£æåŠ å¯†è¾“å…¥
        euint32 asset = TFHE.asEuint32(encryptedAsset);
        euint32 nft = TFHE.asEuint32(encryptedNFT);
        euint32 age = TFHE.asEuint32(encryptedAge);
        euint32 tx = TFHE.asEuint32(encryptedTx);

        // éªŒè¯ inputProof
        require(TFHE.isAllowed(asset, msg.sender), "Invalid asset proof");

        // å­˜å‚¨åŠ å¯†æ•°æ®
        identities[msg.sender] = EncryptedIdentity({
            assetBalance: asset,
            nftCount: nft,
            accountAge: age,
            txCount: tx,
            exists: true
        });

        hasRegistered[msg.sender] = true;
        emit IdentityRegistered(msg.sender);
    }

    // æ›´æ–°èµ„äº§æ•°æ®
    function updateAssetBalance(
        bytes calldata encryptedBalance,
        bytes calldata inputProof
    ) external {
        require(hasRegistered[msg.sender], "Not registered");

        euint32 newBalance = TFHE.asEuint32(encryptedBalance);
        require(TFHE.isAllowed(newBalance, msg.sender), "Invalid proof");

        identities[msg.sender].assetBalance = newBalance;
        emit ProofSubmitted(msg.sender, "asset");
    }

    // å†…éƒ¨ï¼šè·å–ç”¨æˆ·åŠ å¯†æ•°æ®
    function _getEncryptedData(address user) internal view returns (EncryptedIdentity memory) {
        require(identities[user].exists, "User not registered");
        return identities[user];
    }
}
```

#### 2.2.2 ReputationScore.sol

**èŒè´£**: ç®¡ç†ç”¨æˆ·å£°èª‰åˆ†æ•°ï¼ˆæ˜æ–‡å­˜å‚¨ï¼‰

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract ReputationScore {
    struct Reputation {
        uint256 score;              // å½“å‰åˆ†æ•°
        uint256 lastActivityTime;   // æœ€åæ´»è·ƒæ—¶é—´
        uint256 totalVerifications; // å®Œæˆçš„éªŒè¯æ¬¡æ•°
        uint256 totalContributions; // è´¡çŒ®æ¬¡æ•°
    }

    mapping(address => Reputation) public reputations;

    // å£°èª‰ç­‰çº§æšä¸¾
    enum ReputationLevel { Novice, Active, Trusted, Veteran, Legend }

    // åŠ åˆ†äº‹ä»¶
    uint256 public constant REWARD_IDENTITY_VERIFIED = 10;
    uint256 public constant REWARD_DAO_VOTE = 5;
    uint256 public constant REWARD_TX_SUCCESS = 2;
    uint256 public constant REWARD_WEEKLY_ACTIVE = 3;
    uint256 public constant REWARD_OPENSOURCE = 15;

    // å‡åˆ†äº‹ä»¶
    uint256 public constant PENALTY_MALICIOUS_TX = 20;
    uint256 public constant PENALTY_REPORTED = 10;
    uint256 public constant PENALTY_INACTIVE_MONTHLY = 1;

    event ScoreChanged(address indexed user, int256 change, uint256 newScore);
    event LevelUp(address indexed user, ReputationLevel newLevel);

    // æ·»åŠ åˆ†æ•°
    function addScore(address user, uint256 amount) external {
        reputations[user].score += amount;
        reputations[user].lastActivityTime = block.timestamp;
        emit ScoreChanged(user, int256(amount), reputations[user].score);

        // æ£€æŸ¥æ˜¯å¦å‡çº§
        ReputationLevel newLevel = getLevel(user);
        emit LevelUp(user, newLevel);
    }

    // å‡å°‘åˆ†æ•°
    function deductScore(address user, uint256 amount) external {
        uint256 currentScore = reputations[user].score;
        if (currentScore >= amount) {
            reputations[user].score -= amount;
        } else {
            reputations[user].score = 0;
        }
        emit ScoreChanged(user, -int256(amount), reputations[user].score);
    }

    // è·å–ç”¨æˆ·ç­‰çº§
    function getLevel(address user) public view returns (ReputationLevel) {
        uint256 score = reputations[user].score;
        if (score >= 5001) return ReputationLevel.Legend;
        if (score >= 1001) return ReputationLevel.Veteran;
        if (score >= 501) return ReputationLevel.Trusted;
        if (score >= 101) return ReputationLevel.Active;
        return ReputationLevel.Novice;
    }

    // æ£€æŸ¥æ˜¯å¦æ»¡è¶³åˆ†æ•°è¦æ±‚
    function meetsScoreRequirement(address user, uint256 minScore) external view returns (bool) {
        return reputations[user].score >= minScore;
    }
}
```

#### 2.2.3 VerificationService.sol

**èŒè´£**: å¤„ç† dApp çš„éªŒè¯è¯·æ±‚ï¼ˆFHE æ¯”è¾ƒï¼‰

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "fhevm/lib/TFHE.sol";
import "fhevm/gateway/GatewayCaller.sol";
import "./IdentityProofManager.sol";
import "./ReputationScore.sol";

contract VerificationService is GatewayCaller {
    IdentityProofManager public identityManager;
    ReputationScore public reputationScore;

    struct VerificationRequest {
        address requester;      // è¯·æ±‚æ–¹ï¼ˆdAppï¼‰
        address user;           // è¢«éªŒè¯ç”¨æˆ·
        uint32 assetThreshold;  // èµ„äº§é—¨æ§›ï¼ˆæ˜æ–‡ï¼‰
        uint32 accountAgeMin;   // æœ€å°è´¦æˆ·å¹´é¾„ï¼ˆå¤©ï¼‰
        uint256 reputationMin;  // æœ€å°å£°èª‰åˆ†æ•°
        bool isPending;         // æ˜¯å¦ç­‰å¾… Oracle å›è°ƒ
        bool result;            // éªŒè¯ç»“æœ
    }

    mapping(uint256 => VerificationRequest) public requests;
    uint256 public nextRequestId;

    event VerificationRequested(uint256 indexed requestId, address indexed user);
    event VerificationCompleted(uint256 indexed requestId, bool result);

    constructor(address _identityManager, address _reputationScore) {
        identityManager = IdentityProofManager(_identityManager);
        reputationScore = ReputationScore(_reputationScore);
    }

    // dApp è¯·æ±‚éªŒè¯
    function requestVerification(
        address user,
        uint32 assetThreshold,
        uint32 accountAgeMin,
        uint256 reputationMin
    ) external returns (uint256) {
        uint256 requestId = nextRequestId++;

        requests[requestId] = VerificationRequest({
            requester: msg.sender,
            user: user,
            assetThreshold: assetThreshold,
            accountAgeMin: accountAgeMin,
            reputationMin: reputationMin,
            isPending: true,
            result: false
        });

        // å¯åŠ¨ FHE éªŒè¯æµç¨‹
        _performVerification(requestId);

        emit VerificationRequested(requestId, user);
        return requestId;
    }

    // æ‰§è¡Œ FHE éªŒè¯ï¼ˆå†…éƒ¨ï¼‰
    function _performVerification(uint256 requestId) internal {
        VerificationRequest storage req = requests[requestId];

        // 1ï¸âƒ£ è·å–ç”¨æˆ·åŠ å¯†æ•°æ®
        IdentityProofManager.EncryptedIdentity memory identity =
            identityManager._getEncryptedData(req.user);

        // 2ï¸âƒ£ FHE æ¯”è¾ƒï¼šèµ„äº§ >= é—¨æ§›
        ebool assetMeetsThreshold = TFHE.gte(
            identity.assetBalance,
            TFHE.asEuint32(req.assetThreshold)
        );

        // 3ï¸âƒ£ FHE æ¯”è¾ƒï¼šè´¦æˆ·å¹´é¾„ >= æœ€å°å€¼
        ebool ageMeetsThreshold = TFHE.gte(
            identity.accountAge,
            TFHE.asEuint32(req.accountAgeMin)
        );

        // 4ï¸âƒ£ ç»„åˆæ¡ä»¶ï¼ˆANDï¼‰
        ebool meetsAllCriteria = TFHE.and(assetMeetsThreshold, ageMeetsThreshold);

        // 5ï¸âƒ£ è¯·æ±‚ Oracle è§£å¯†ç»“æœ
        uint256[] memory cts = new uint256[](1);
        cts[0] = Gateway.toUint256(meetsAllCriteria);

        Gateway.requestDecryption(
            cts,
            this.handleOracleCallback.selector,
            0, // maxTimestamp (ä¸é™åˆ¶)
            false, // blockOnError
            false // allowMocked
        );
    }

    // Oracle å›è°ƒï¼ˆå¼‚æ­¥ï¼‰
    function handleOracleCallback(
        uint256 /*requestId*/,
        bool decryptedResult
    ) public onlyGateway {
        // è§£å¯†åçš„å¸ƒå°”ç»“æœ
        uint256 reqId = nextRequestId - 1; // ç®€åŒ–å¤„ç†ï¼ˆå®é™…éœ€è¦æ˜ å°„ï¼‰
        VerificationRequest storage req = requests[reqId];

        // 6ï¸âƒ£ æ£€æŸ¥å£°èª‰åˆ†æ•°ï¼ˆæ˜æ–‡æ¯”è¾ƒï¼‰
        bool meetsReputation = reputationScore.meetsScoreRequirement(
            req.user,
            req.reputationMin
        );

        // 7ï¸âƒ£ æœ€ç»ˆç»“æœ = FHE éªŒè¯ AND å£°èª‰éªŒè¯
        bool finalResult = decryptedResult && meetsReputation;

        req.result = finalResult;
        req.isPending = false;

        emit VerificationCompleted(reqId, finalResult);

        // 8ï¸âƒ£ å¦‚æœé€šè¿‡ï¼Œå¢åŠ å£°èª‰åˆ†æ•°
        if (finalResult) {
            reputationScore.addScore(req.user, reputationScore.REWARD_IDENTITY_VERIFIED());
        }
    }

    // æŸ¥è¯¢éªŒè¯ç»“æœ
    function getVerificationResult(uint256 requestId) external view returns (bool) {
        require(!requests[requestId].isPending, "Still pending");
        return requests[requestId].result;
    }
}
```

#### 2.2.4 CredentialNFT.sol

**èŒè´£**: é¢å‘ä¸å¯è½¬è®©çš„èº«ä»½è¯ä¹¦ï¼ˆSBTï¼‰

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract CredentialNFT is ERC721 {
    enum CredentialType { KYC, HighNetWorth, ActiveUser, Developer }

    struct Credential {
        CredentialType credType;
        uint256 issuedAt;
        uint256 expiresAt;
        bool isRevoked;
    }

    mapping(uint256 => Credential) public credentials;
    uint256 public nextTokenId;

    address public issuer; // VerificationService åˆçº¦

    event CredentialIssued(address indexed to, uint256 tokenId, CredentialType credType);
    event CredentialRevoked(uint256 tokenId);

    constructor() ERC721("PrivyRep Credential", "PRIVY-CRED") {
        issuer = msg.sender;
    }

    modifier onlyIssuer() {
        require(msg.sender == issuer, "Not authorized");
        _;
    }

    // é¢å‘è¯ä¹¦
    function issueCredential(
        address to,
        CredentialType credType,
        uint256 validityDays
    ) external onlyIssuer returns (uint256) {
        uint256 tokenId = nextTokenId++;

        credentials[tokenId] = Credential({
            credType: credType,
            issuedAt: block.timestamp,
            expiresAt: block.timestamp + (validityDays * 1 days),
            isRevoked: false
        });

        _mint(to, tokenId);
        emit CredentialIssued(to, tokenId, credType);
        return tokenId;
    }

    // æ’¤é”€è¯ä¹¦
    function revokeCredential(uint256 tokenId) external onlyIssuer {
        require(_exists(tokenId), "Token doesn't exist");
        credentials[tokenId].isRevoked = true;
        emit CredentialRevoked(tokenId);
    }

    // æ£€æŸ¥è¯ä¹¦æ˜¯å¦æœ‰æ•ˆ
    function isCredentialValid(uint256 tokenId) public view returns (bool) {
        if (!_exists(tokenId)) return false;

        Credential memory cred = credentials[tokenId];
        if (cred.isRevoked) return false;
        if (block.timestamp > cred.expiresAt) return false;

        return true;
    }

    // ğŸš« ç¦æ­¢è½¬ç§»ï¼ˆSBTï¼‰
    function _transfer(
        address /*from*/,
        address /*to*/,
        uint256 /*tokenId*/
    ) internal pure override {
        revert("Soulbound: Transfer not allowed");
    }
}
```

---

## 3. FHE å®ç°ç»†èŠ‚

### 3.0 SDK åˆå§‹åŒ– - CDN åŠ è½½æ–¹æ¡ˆï¼ˆå…³é”®æŠ€æœ¯ç‚¹ï¼‰â­

**é—®é¢˜èƒŒæ™¯ï¼š**
ä½¿ç”¨ npm åŒ… `@zama-fhe/relayer-sdk` ä¼šå¯¼è‡´ Vite bundler æ— æ³•æ­£ç¡®å¤„ç† WASM æ–‡ä»¶ï¼Œå‡ºç°ä»¥ä¸‹é”™è¯¯ï¼š
```
WebAssembly.instantiate(): expected magic word 00 61 73 6d, found 3c 21 64 6f
```

**æ ¹æœ¬åŸå› ï¼š**
- WASM æ–‡ä»¶åœ¨æ‰“åŒ…è¿‡ç¨‹ä¸­è·¯å¾„è§£æå¤±è´¥
- Vite 7.x ä¸ WASM bundling å­˜åœ¨å…¼å®¹æ€§é—®é¢˜
- æœåŠ¡å™¨è¿”å› HTML é”™è¯¯é¡µï¼ˆ`<!do...`ï¼‰è€Œä¸æ˜¯ WASM äºŒè¿›åˆ¶æ–‡ä»¶

**âœ… è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨ CDN åŠ¨æ€åŠ è½½ï¼ˆZamabelief éªŒè¯æ–¹æ¡ˆï¼‰**

```typescript
// services/fheService.ts

/**
 * ä» Zama CDN åŠ¨æ€åŠ è½½ SDKï¼Œé¿å…æœ¬åœ°æ‰“åŒ…é—®é¢˜
 * å‚è€ƒï¼šZamabelief é¡¹ç›®çš„æˆåŠŸå®è·µ
 */
export async function initializeFheInstance(): Promise<FhevmInstance> {
  console.log('ğŸ”§ [FHE] Initializing FHE instance...');

  try {
    // â­ å…³é”®ç‚¹ 1ï¼šä» CDN åŠ¨æ€å¯¼å…¥ï¼Œè€Œä¸æ˜¯ npm åŒ…
    // âŒ é”™è¯¯åšæ³•ï¼šconst sdk = await import('@zama-fhe/relayer-sdk/web');
    // âœ… æ­£ç¡®åšæ³•ï¼šä» CDN åŠ è½½
    const sdk: any = await import('https://cdn.zama.ai/relayer-sdk-js/0.2.0/relayer-sdk-js.js');

    const { initSDK, createInstance, SepoliaConfig } = sdk;

    // â­ å…³é”®ç‚¹ 2ï¼šè°ƒç”¨ initSDK() åŠ è½½ WASM æ¨¡å—
    await initSDK();

    // â­ å…³é”®ç‚¹ 3ï¼šä½¿ç”¨ SepoliaConfig å’Œ window.ethereum
    const config = { ...SepoliaConfig, network: window.ethereum };
    const instance = await createInstance(config);

    return instance;
  } catch (error: any) {
    console.error('âŒ [FHE] FHEVM instance creation failed:', error);
    throw error;
  }
}
```

**æŠ€æœ¯è¦ç‚¹ï¼š**

1. **ä¸ºä»€ä¹ˆ CDN æ–¹å¼æœ‰æ•ˆï¼Ÿ**
   - ç»•è¿‡ Vite bundlerï¼Œé¿å… WASM è·¯å¾„è§£æé—®é¢˜
   - ä½¿ç”¨æµè§ˆå™¨åŸç”Ÿçš„ HTTP imports åŠŸèƒ½
   - WASM æ–‡ä»¶ç”± CDN ç›´æ¥æä¾›ï¼Œæ— éœ€æœ¬åœ°æ‰“åŒ…
   - é”å®šç»è¿‡æµ‹è¯•çš„ 0.2.0 ç‰ˆæœ¬

2. **Vite é…ç½®ç®€åŒ–ï¼š**
   ```typescript
   // vite.config.ts - ä¸éœ€è¦ vite-plugin-wasmï¼
   export default defineConfig({
     plugins: [
       react(),
       nodePolyfills()  // åªéœ€è¦ Node.js polyfills
     ],
     optimizeDeps: {
       include: ['buffer', 'process', 'util', 'crypto']
     },
     define: {
       global: 'globalThis'
     }
   })
   ```

3. **ä¸éœ€è¦çš„æ’ä»¶ï¼š**
   - âŒ `vite-plugin-wasm` - ä¸éœ€è¦
   - âŒ `vite-plugin-top-level-await` - ä¸éœ€è¦
   - âŒ å¤æ‚çš„ WASM asset é…ç½® - ä¸éœ€è¦

4. **æ€§èƒ½å¯¹æ¯”ï¼š**
   | æ–¹æ¡ˆ | åŠ è½½æ—¶é—´ | å¯é æ€§ | ç»´æŠ¤æˆæœ¬ |
   |------|---------|--------|---------|
   | NPM åŒ… | âŒ å¤±è´¥ | âŒ ä½ | ğŸ”´ é«˜ |
   | CDN æ–¹å¼ | âœ… ~2-3ç§’ | âœ… é«˜ | ğŸŸ¢ ä½ |

**å‚è€ƒå®ç°ï¼š**
- Zamabelief é¡¹ç›®ï¼š`src/utils/fheInstance.ts`
- å®˜æ–¹æ–‡æ¡£ï¼šhttps://docs.zama.ai/fhevm

### 3.0.1 React å‰¯ä½œç”¨ç®¡ç†å…³é”®ç‚¹ â­

**é—®é¢˜èƒŒæ™¯ï¼š**
åœ¨ä½¿ç”¨ `wagmi` å’Œ `react-hot-toast` æ—¶ï¼Œå¦‚æœåœ¨ç»„ä»¶æ¸²æŸ“æœŸé—´ç›´æ¥è°ƒç”¨ toastï¼Œä¼šå¯¼è‡´Reacté”™è¯¯ï¼š"Cannot update a component while rendering a different component"ã€‚

**âŒ é”™è¯¯åšæ³•ï¼šåœ¨æ¸²æŸ“æœŸé—´è°ƒç”¨å‰¯ä½œç”¨**

```typescript
export function VerificationRequest() {
  const { writeContract, data: hash, isPending } = useWriteContract();
  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({ hash });

  // âŒ é”™è¯¯ï¼šåœ¨æ¸²æŸ“æœŸé—´ç›´æ¥è°ƒç”¨ toast
  if (isSuccess) {
    toast.success('éªŒè¯è¯·æ±‚å·²æäº¤ï¼', { id: hash });
  }

  if (error) {
    toast.error(`äº¤æ˜“å¤±è´¥: ${error.message}`, { id: 'tx-error' });
  }

  return <div>...</div>;
}
```

**âœ… æ­£ç¡®åšæ³•ï¼šä½¿ç”¨ useEffect å¤„ç†å‰¯ä½œç”¨**

```typescript
import { useState, useEffect } from 'react';

export function VerificationRequest() {
  const { writeContract, data: hash, isPending, error } = useWriteContract();
  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({ hash });

  // âœ… æ­£ç¡®ï¼šåœ¨ useEffect ä¸­å¤„ç†å‰¯ä½œç”¨
  useEffect(() => {
    if (isSuccess && hash) {
      toast.success('éªŒè¯è¯·æ±‚å·²æäº¤ï¼', { id: hash });
    }
  }, [isSuccess, hash]);

  useEffect(() => {
    if (error) {
      toast.error(`äº¤æ˜“å¤±è´¥: ${error.message}`, { id: 'tx-error' });
    }
  }, [error]);

  return <div>...</div>;
}
```

**å…³é”®åŸå› ï¼š**

1. **React æ¸²æŸ“åŸåˆ™**ï¼šç»„ä»¶çš„æ¸²æŸ“å‡½æ•°åº”è¯¥æ˜¯çº¯å‡½æ•°ï¼Œä¸åº”åŒ…å«å‰¯ä½œç”¨
2. **çŠ¶æ€æ›´æ–°éš”ç¦»**ï¼štoast ä¼šè§¦å‘å…¶ä»–ç»„ä»¶çš„çŠ¶æ€æ›´æ–°ï¼Œå¿…é¡»åœ¨å‰¯ä½œç”¨é˜¶æ®µæ‰§è¡Œ
3. **ä¾èµ–è·Ÿè¸ª**ï¼šuseEffect çš„ä¾èµ–æ•°ç»„ç¡®ä¿å‰¯ä½œç”¨åªåœ¨å¿…è¦æ—¶æ‰§è¡Œ

**é€‚ç”¨åœºæ™¯ï¼š**

- âœ… Toast é€šçŸ¥
- âœ… äº‹ä»¶è¿½è¸ªï¼ˆAnalyticsï¼‰
- âœ… æœ¬åœ°å­˜å‚¨æ“ä½œ
- âœ… è®¢é˜…/å–æ¶ˆè®¢é˜…
- âœ… æ‰‹åŠ¨ DOM æ“ä½œ

**é”™è¯¯ç—‡çŠ¶ï¼š**

```
Cannot update a component (`Fe`) while rendering a different component (`VerificationRequest`).
To locate the bad setState() call inside `VerificationRequest`, follow the stack trace...
```

**å‚è€ƒå®ç°ï¼š**
- PrivyRep é¡¹ç›®ï¼š`src/components/IdentityRegistration.tsx`
- PrivyRep é¡¹ç›®ï¼š`src/components/VerificationRequest.tsx`
- React å®˜æ–¹æ–‡æ¡£ï¼šhttps://react.dev/reference/react/useEffect

### 3.1 åŠ å¯†æµç¨‹

```typescript
// services/fheService.ts

export async function encryptUserData(
  assetBalance: number,
  nftCount: number,
  accountAge: number,
  txCount: number,
  userAddress: string
): Promise<EncryptedInputs> {
  const instance = await getFhevmInstance();

  // 1ï¸âƒ£ åˆ›å»ºåŠ å¯†è¾“å…¥å¯¹è±¡
  const input = instance.createEncryptedInput(
    CONTRACT_ADDRESS,
    userAddress
  );

  // 2ï¸âƒ£ æ·»åŠ  4 ä¸ª uint32 å€¼
  input.add32(assetBalance);
  input.add32(nftCount);
  input.add32(accountAge);
  input.add32(txCount);

  // 3ï¸âƒ£ æ‰§è¡ŒåŠ å¯†
  const encryptedData = await input.encrypt();

  // ğŸ”¥ å…³é”®ä¿®å¤ï¼šä½¿ç”¨ ethers.utils.hexlify è½¬æ¢ï¼ˆå‚è€ƒ Zamabeliefï¼‰
  // âŒ é”™è¯¯ï¼šä½¿ç”¨è‡ªå®šä¹‰ uint8ArrayToHex ä¼šå¯¼è‡´æ ¼å¼é—®é¢˜
  // âœ… æ­£ç¡®ï¼šä½¿ç”¨ ethers v5 çš„ utils.hexlify
  const handles = encryptedData.handles.map((h: any) => utils.hexlify(h) as `0x${string}`);
  const inputProof = utils.hexlify(encryptedData.inputProof) as `0x${string}`;

  return {
    encryptedAsset: handles[0],
    encryptedNFT: handles[1],
    encryptedAge: handles[2],
    encryptedTx: handles[3],
    inputProof: inputProof,
  };
}
```

#### ğŸ”¥ å…³é”®é—®é¢˜ï¼šhexlify å‡½æ•°çš„æ­£ç¡®å¯¼å…¥ï¼ˆethers v5 å…¼å®¹æ€§ï¼‰

**é—®é¢˜ç—‡çŠ¶ï¼š**
- é¡µé¢ç©ºç™½
- æ§åˆ¶å°é”™è¯¯ï¼š`The requested module does not provide an export named 'hexlify'`
- Vite ç¼–è¯‘å¤±è´¥

**æ ¹æœ¬åŸå› ï¼š** åœ¨ ethers v5 ä¸­ï¼Œ`hexlify` ä¸æ˜¯é¡¶çº§å¯¼å‡ºï¼Œè€Œæ˜¯åœ¨ `utils` æ¨¡å—ä¸‹ã€‚

**âŒ é”™è¯¯çš„å¯¼å…¥æ–¹å¼ï¼ˆä¸å…¼å®¹ ethers v5ï¼‰ï¼š**

```typescript
// services/fheService.ts

import { hexlify } from 'ethers';  // âŒ åœ¨ ethers v5 ä¸­ä¼šå¤±è´¥ï¼

export async function encryptIdentityData(...) {
  // ...
  const handles = encryptedInput.handles.map((h: any) => hexlify(h));  // âŒ é”™è¯¯
  const inputProof = hexlify(encryptedInput.inputProof);  // âŒ é”™è¯¯
  // ...
}
```

**âœ… æ­£ç¡®çš„å¯¼å…¥æ–¹å¼ï¼ˆå…¼å®¹ ethers v5ï¼‰ï¼š**

```typescript
// services/fheService.ts

import { utils } from 'ethers';  // âœ… æ­£ç¡®ï¼ä» utils å¯¼å…¥

export async function encryptIdentityData(...) {
  const encryptedInput = await input.encrypt();

  // âœ… ä½¿ç”¨ utils.hexlify è½¬æ¢åŠ å¯†æ•°æ®
  const handles = encryptedInput.handles.map((h: any) =>
    utils.hexlify(h) as `0x${string}`
  );
  const inputProof = utils.hexlify(encryptedInput.inputProof) as `0x${string}`;

  return {
    encryptedAsset: handles[0],
    encryptedNFT: handles[1],
    encryptedAge: handles[2],
    encryptedTx: handles[3],
    inputProof: inputProof,
  };
}
```

**æŠ€æœ¯åŸç†ï¼š**

åœ¨ ethers.js çš„ä¸åŒç‰ˆæœ¬ä¸­ï¼Œ`hexlify` çš„å¯¼å‡ºä½ç½®ä¸åŒï¼š

| ethers ç‰ˆæœ¬ | hexlify å¯¼å…¥æ–¹å¼ | ä½¿ç”¨æ–¹å¼ |
|------------|----------------|---------|
| ethers v5.x | `import { utils } from 'ethers'` | `utils.hexlify(data)` |
| ethers v6.x | `import { hexlify } from 'ethers'` | `hexlify(data)` |

**Zamabelief å‚è€ƒï¼š**
- Zamabelief é¡¹ç›®ä½¿ç”¨ `ethers@5.8.0`
- ä»–ä»¬çš„å®ç°ä¹Ÿä½¿ç”¨ `utils.hexlify` è¿›è¡Œè½¬æ¢
- æ–‡ä»¶ä½ç½®ï¼š`zamabelief/src/hooks/useCastVote.ts`

**ä¸ºä»€ä¹ˆå¿…é¡»ä½¿ç”¨ hexlifyï¼š**

1. **æ ¼å¼æ ‡å‡†åŒ–**ï¼š`hexlify` ç¡®ä¿è¾“å‡ºçš„åå…­è¿›åˆ¶å­—ç¬¦ä¸²ç¬¦åˆä»¥å¤ªåŠæ ‡å‡†æ ¼å¼
2. **ç±»å‹å…¼å®¹**ï¼š`hexlify` çš„è¾“å‡ºç±»å‹ä¸åˆçº¦ ABI æœŸæœ›çš„ `bytes` ç±»å‹å®Œå…¨åŒ¹é…
3. **Uint8Array å¤„ç†**ï¼šFHEVM SDK è¿”å›çš„ handles å’Œ inputProof æ˜¯ Uint8Array ç±»å‹ï¼Œå¿…é¡»è½¬æ¢ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä¸²æ‰èƒ½ä¼ é€’ç»™åˆçº¦

**âŒ è‡ªå®šä¹‰è½¬æ¢å‡½æ•°çš„é—®é¢˜ï¼š**

```typescript
// âŒ ä¸æ¨èï¼šè‡ªå®šä¹‰è½¬æ¢å‡½æ•°å¯èƒ½å¯¼è‡´æ ¼å¼ä¸å…¼å®¹
function uint8ArrayToHex(uint8Array: Uint8Array): `0x${string}` {
  return `0x${Array.from(uint8Array)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')}` as `0x${string}`;
}
```

è™½ç„¶è¿™ä¸ªè‡ªå®šä¹‰å‡½æ•°åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹å¯ä»¥å·¥ä½œï¼Œä½†ï¼š
- ç¼ºå°‘ ethers.js çš„é¢å¤–éªŒè¯å’Œè§„èŒƒåŒ–
- å¯èƒ½åœ¨è¾¹ç•Œæƒ…å†µä¸‹äº§ç”Ÿä¸ä¸€è‡´çš„ç»“æœ
- ä¸éµå¾ª Zama å®˜æ–¹ç¤ºä¾‹çš„æœ€ä½³å®è·µ

**æœ€ä½³å®è·µæ€»ç»“ï¼š**

1. **æ£€æŸ¥ ethers ç‰ˆæœ¬**ï¼šç¡®è®¤é¡¹ç›®ä½¿ç”¨çš„æ˜¯ ethers v5 è¿˜æ˜¯ v6
2. **ä½¿ç”¨æ­£ç¡®å¯¼å…¥**ï¼šethers v5 ä½¿ç”¨ `utils.hexlify`ï¼Œv6 ä½¿ç”¨é¡¶çº§ `hexlify`
3. **å‚è€ƒå®˜æ–¹ç¤ºä¾‹**ï¼šä¼˜å…ˆä½¿ç”¨ Zama å’Œ ethers.js å®˜æ–¹æ¨èçš„è½¬æ¢æ–¹æ³•
4. **é¿å…è‡ªå®šä¹‰**ï¼šé™¤éæœ‰ç‰¹æ®Šéœ€æ±‚ï¼Œå¦åˆ™ä¸è¦è‡ªå·±å®ç° hex è½¬æ¢å‡½æ•°



### 3.2 è§£å¯†æµç¨‹ï¼ˆOracle Callbackï¼‰

```
ç”¨æˆ·æäº¤åŠ å¯†æ•°æ®
        â†“
åˆçº¦æ‰§è¡Œ FHE æ¯”è¾ƒï¼ˆeuint32 >= thresholdï¼‰
        â†“
Gateway.requestDecryption(ebool)
        â†“
[ç­‰å¾… Zama Oracle å¤„ç†...]
        â†“
Oracle è°ƒç”¨ handleOracleCallback(bool decryptedResult)
        â†“
åˆçº¦æ ¹æ®è§£å¯†ç»“æœæ‰§è¡Œé€»è¾‘ï¼ˆå‘æ”¾ NFTã€å¢åŠ å£°èª‰ç­‰ï¼‰
```

### 3.3 æ”¯æŒçš„ FHE æ“ä½œ

| æ“ä½œç±»å‹ | Solidity å‡½æ•° | ç”¨é€”ç¤ºä¾‹ |
|---------|--------------|----------|
| æ¯”è¾ƒ | `TFHE.gte(euint32, euint32)` | éªŒè¯èµ„äº§ >= é—¨æ§› |
| é€»è¾‘ä¸ | `TFHE.and(ebool, ebool)` | ç»„åˆå¤šä¸ªæ¡ä»¶ |
| é€»è¾‘æˆ– | `TFHE.or(ebool, ebool)` | æ»¡è¶³ä»»ä¸€æ¡ä»¶ |
| è§£å¯†è¯·æ±‚ | `Gateway.requestDecryption()` | è·å–æœ€ç»ˆ Pass/Fail |

---

## 4. å‰ç«¯æ¶æ„

### 4.1 ç›®å½•ç»“æ„

```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Dashboard/
â”‚   â”‚   â”œâ”€â”€ ReputationCard.tsx      # å£°èª‰åˆ†æ•°å±•ç¤º
â”‚   â”‚   â”œâ”€â”€ CredentialList.tsx      # è¯ä¹¦åˆ—è¡¨
â”‚   â”‚   â””â”€â”€ ActivityTimeline.tsx    # æ´»åŠ¨æ—¶é—´çº¿
â”‚   â”œâ”€â”€ Verification/
â”‚   â”‚   â”œâ”€â”€ ProofSubmitForm.tsx     # æäº¤è¯æ˜è¡¨å•
â”‚   â”‚   â”œâ”€â”€ VerificationStatus.tsx  # éªŒè¯çŠ¶æ€å±•ç¤º
â”‚   â”‚   â””â”€â”€ PrivacyNotice.tsx       # éšç§è¯´æ˜
â”‚   â””â”€â”€ Credentials/
â”‚       â”œâ”€â”€ CredentialCard.tsx      # å•ä¸ªè¯ä¹¦å¡ç‰‡
â”‚       â””â”€â”€ CredentialDetail.tsx    # è¯ä¹¦è¯¦æƒ…
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ fheService.ts              # FHE åŠ å¯†æœåŠ¡
â”‚   â”œâ”€â”€ contractService.ts         # åˆçº¦è°ƒç”¨å°è£…
â”‚   â””â”€â”€ dataCollector.ts           # ç”¨æˆ·æ•°æ®é‡‡é›†
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useFheInstance.ts          # FHE å®ä¾‹ç®¡ç†
â”‚   â”œâ”€â”€ useReputation.ts           # å£°èª‰æ•°æ®é’©å­
â”‚   â””â”€â”€ useVerification.ts         # éªŒè¯æµç¨‹é’©å­
â”œâ”€â”€ store/
â”‚   â””â”€â”€ userStore.ts               # Zustand çŠ¶æ€ç®¡ç†
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ fhevm.ts                   # FHEVM å·¥å…·å‡½æ•°
â”‚   â””â”€â”€ constants.ts               # å¸¸é‡å®šä¹‰
â””â”€â”€ pages/
    â”œâ”€â”€ Home.tsx
    â”œâ”€â”€ Dashboard.tsx
    â”œâ”€â”€ Verify.tsx
    â””â”€â”€ Credentials.tsx
```

### 4.2 å…³é”®ç»„ä»¶è®¾è®¡

#### ProofSubmitForm.tsx

```tsx
export function ProofSubmitForm() {
  const { address } = useAccount();
  const { data: balance } = useBalance({ address });
  const { encryptAndSubmit, isPending } = useVerification();

  const handleSubmit = async () => {
    // 1ï¸âƒ£ æ”¶é›†ç”¨æˆ·æ•°æ®
    const userData = {
      assetBalance: parseFloat(formatEther(balance?.value || 0n)) * 1000, // è½¬ä¸º milli-ETH
      nftCount: await fetchNFTCount(address),
      accountAge: await calculateAccountAge(address),
      txCount: await fetchTransactionCount(address),
    };

    // 2ï¸âƒ£ åŠ å¯†å¹¶æäº¤
    await encryptAndSubmit(userData);
  };

  return (
    <div className="space-y-6">
      <WalletBalanceDisplay balance={balance} />
      <PrivacyNotice />
      <button
        onClick={handleSubmit}
        disabled={isPending}
        className="btn-primary"
      >
        {isPending ? "Encrypting..." : "Submit Proof"}
      </button>
    </div>
  );
}
```

#### useVerification.ts Hook

```typescript
export function useVerification() {
  const { writeContract } = useWriteContract();
  const [isPending, setIsPending] = useState(false);

  const encryptAndSubmit = async (userData: UserData) => {
    setIsPending(true);
    try {
      // 1ï¸âƒ£ åŠ å¯†æ•°æ®
      const encrypted = await encryptUserData(
        userData.assetBalance,
        userData.nftCount,
        userData.accountAge,
        userData.txCount,
        address!
      );

      // 2ï¸âƒ£ è°ƒç”¨åˆçº¦
      writeContract({
        address: IDENTITY_MANAGER_ADDRESS,
        abi: IdentityManagerABI,
        functionName: "registerIdentity",
        args: [
          encrypted.encryptedAsset,
          encrypted.encryptedNFT,
          encrypted.encryptedAge,
          encrypted.encryptedTx,
          encrypted.inputProof,
        ],
      });
    } catch (error) {
      console.error("Verification failed:", error);
      throw error;
    } finally {
      setIsPending(false);
    }
  };

  return { encryptAndSubmit, isPending };
}
```

---

## 5. dApp é›†æˆ SDK

### 5.1 SDK è®¾è®¡

```typescript
// @privyrep/sdk

export class PrivyRepSDK {
  private verificationService: ethers.Contract;

  constructor(provider: ethers.Provider, contractAddress: string) {
    this.verificationService = new ethers.Contract(
      contractAddress,
      VerificationServiceABI,
      provider
    );
  }

  // è¯·æ±‚éªŒè¯
  async requestVerification(params: {
    userAddress: string;
    assetThreshold: number;
    accountAgeMin?: number;
    reputationMin?: number;
  }): Promise<string> {
    const tx = await this.verificationService.requestVerification(
      params.userAddress,
      params.assetThreshold,
      params.accountAgeMin || 0,
      params.reputationMin || 0
    );

    const receipt = await tx.wait();
    const requestId = receipt.events[0].args.requestId;
    return requestId;
  }

  // æŸ¥è¯¢éªŒè¯ç»“æœ
  async getVerificationResult(requestId: string): Promise<boolean> {
    return await this.verificationService.getVerificationResult(requestId);
  }

  // ç›‘å¬éªŒè¯å®Œæˆäº‹ä»¶
  onVerificationCompleted(
    callback: (requestId: string, result: boolean) => void
  ) {
    this.verificationService.on("VerificationCompleted", callback);
  }
}
```

### 5.2 ä½¿ç”¨ç¤ºä¾‹

```typescript
// dApp é›†æˆç¤ºä¾‹

import { PrivyRepSDK } from "@privyrep/sdk";

const sdk = new PrivyRepSDK(provider, VERIFICATION_SERVICE_ADDRESS);

// åœºæ™¯ï¼šç©ºæŠ•ç™½åå•éªŒè¯
async function checkAirdropEligibility(userAddress: string) {
  const requestId = await sdk.requestVerification({
    userAddress,
    assetThreshold: 5000, // 5 ETH (milli-ETH)
    accountAgeMin: 365,   // 1 year
    reputationMin: 100,   // Active user level
  });

  // ç›‘å¬ç»“æœ
  sdk.onVerificationCompleted((id, result) => {
    if (id === requestId && result) {
      console.log("User eligible for airdrop!");
      // æ·»åŠ åˆ°ç™½åå•...
    }
  });
}
```

---

## 6. æ•°æ®æµè®¾è®¡

### 6.1 ç”¨æˆ·æ³¨å†Œæµç¨‹

```
User â†’ Frontend â†’ FHE Service â†’ Blockchain
 â”‚                    â”‚              â”‚
 â”‚      é‡‡é›†æ•°æ®        â”‚     åŠ å¯†      â”‚
 â”‚   (ä½™é¢/NFT/...)    â”‚              â”‚
 â”‚                    â”‚              â”‚
 â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
 â”‚    è¿”å›åŠ å¯†æ•°æ®                     â”‚
 â”‚                                   â”‚
 â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
       æäº¤ registerIdentity()        â”‚
                                     â”‚
                              å­˜å‚¨åŠ å¯†æ•°æ®
```

### 6.2 éªŒè¯è¯·æ±‚æµç¨‹

```
dApp â†’ VerificationService â†’ IdentityManager â†’ Gateway
 â”‚            â”‚                      â”‚             â”‚
 â”‚  è¯·æ±‚éªŒè¯   â”‚                      â”‚             â”‚
 â”‚           â”‚  è·å–åŠ å¯†æ•°æ®          â”‚             â”‚
 â”‚           â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
 â”‚           â”‚                                    â”‚
 â”‚           â”‚  FHE æ¯”è¾ƒ (gte/and)                â”‚
 â”‚           â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
 â”‚           â”‚                                    â”‚
 â”‚           â”‚            â”Œâ”€â”€â”€ Oracle â”€â”€â”€â”€â”       â”‚
 â”‚           â”‚            â”‚   è§£å¯† ebool   â”‚       â”‚
 â”‚           â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
 â”‚           â”‚                                    â”‚
 â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  è¿”å› Pass/Fail                   â”‚
    å‘é€ Webhook/Event
```

---

## 7. å®‰å…¨æ€§è®¾è®¡

### 7.1 æ”»å‡»é¢åˆ†æ

| æ”»å‡»ç±»å‹ | é£é™©æè¿° | ç¼“è§£æªæ–½ |
|---------|---------|---------|
| **å¥³å·«æ”»å‡»** | ä¸€äººåˆ›å»ºå¤šè´¦æˆ·åˆ·å£°èª‰ | 1ï¸âƒ£ è¦æ±‚åˆå§‹èº«ä»½éªŒè¯ï¼ˆèµ„äº§/NFTï¼‰<br>2ï¸âƒ£ å£°èª‰ç´¯ç§¯éœ€è¦æ—¶é—´æˆæœ¬<br>3ï¸âƒ£ é›†æˆå¤–éƒ¨ KYCï¼ˆæœªæ¥ï¼‰ |
| **é‡æ”¾æ”»å‡»** | å¤ç”¨æ—§çš„åŠ å¯†è¯æ˜ | inputProof åŒ…å« nonce å’Œæ—¶é—´æˆ³ |
| **å‰ç«¯ç¯¡æ”¹** | ä¿®æ”¹å‰ç«¯ä»£ç æäº¤å‡æ•°æ® | åˆçº¦éªŒè¯ inputProof å¯†ç å­¦ç­¾å |
| **Oracle æ“çºµ** | æ”»å‡»è€…è¯•å›¾å½±å“è§£å¯†ç»“æœ | ä½¿ç”¨ Zama å®˜æ–¹ Oracleï¼ˆå¯ä¿¡ï¼‰ |
| **åˆçº¦æ¼æ´** | Reentrancyã€Overflow ç­‰ | 1ï¸âƒ£ ä½¿ç”¨ OpenZeppelin åº“<br>2ï¸âƒ£ ä»£ç å®¡è®¡<br>3ï¸âƒ£ Bug Bounty |

### 7.2 éšç§ä¿æŠ¤æªæ–½

1. **é“¾ä¸Šæ•°æ®åŠ å¯†**: æ‰€æœ‰æ•æ„Ÿæ•°æ®ï¼ˆèµ„äº§ã€NFT æ•°é‡ç­‰ï¼‰ä»¥ euint32 å½¢å¼å­˜å‚¨ï¼Œæ— æ³•é€†å‘
2. **é›¶çŸ¥è¯†è¯æ˜**: éªŒè¯ç»“æœåªè¿”å›å¸ƒå°”å€¼ï¼ˆPass/Failï¼‰ï¼Œä¸æ³„éœ²å…·ä½“æ•°å€¼
3. **æƒé™æ§åˆ¶**: åªæœ‰æ•°æ®æ‰€æœ‰è€…å¯ä»¥æ›´æ–°è‡ªå·±çš„åŠ å¯†æ•°æ®
4. **è§£å¯†é™åˆ¶**: Oracle å›è°ƒåªè¿”å›å¿…è¦çš„å¸ƒå°”ç»“æœï¼Œä¸è§£å¯†åŸå§‹æ•°æ®

### 7.3 å®¡è®¡æ¸…å•

- [ ] Slither é™æ€åˆ†æ
- [ ] Mythril ç¬¦å·æ‰§è¡Œ
- [ ] æ‰‹åŠ¨ä»£ç å®¡è®¡ï¼ˆå¤–éƒ¨å›¢é˜Ÿï¼‰
- [ ] Gas ä¼˜åŒ–å®¡æŸ¥
- [ ] FHE æ“ä½œæ­£ç¡®æ€§éªŒè¯
- [ ] Oracle å›è°ƒå®‰å…¨æ€§æµ‹è¯•

---

## 8. æ€§èƒ½ä¼˜åŒ–

### 8.1 Gas ä¼˜åŒ–ç­–ç•¥

1. **æ‰¹é‡æ“ä½œ**: å…è®¸ç”¨æˆ·ä¸€æ¬¡æ›´æ–°å¤šä¸ªå±æ€§
2. **äº‹ä»¶å‹ç¼©**: å‡å°‘ event å‚æ•°æ•°é‡
3. **å­˜å‚¨ä¼˜åŒ–**: ä½¿ç”¨ `uint32` è€Œé `uint256`
4. **å†·çƒ­æ•°æ®åˆ†ç¦»**: å¸¸ç”¨æ•°æ®å­˜ä¸»åˆçº¦ï¼Œå†å²è®°å½•å­˜å­åˆçº¦

### 8.2 FHE æ€§èƒ½ä¼˜åŒ–

1. **å‡å°‘ FHE æ“ä½œæ¬¡æ•°**:
   - å…ˆéªŒè¯æ˜æ–‡æ¡ä»¶ï¼ˆå£°èª‰åˆ†æ•°ï¼‰
   - å†æ‰§è¡Œ FHE æ¯”è¾ƒï¼ˆå‡å°‘ Gasï¼‰

2. **æ‰¹é‡è§£å¯†**:
   - ä¸€æ¬¡ `requestDecryption` è§£å¯†å¤šä¸ª ebool
   - å‡å°‘ Oracle å›è°ƒæ¬¡æ•°

### 8.3 å‰ç«¯ä¼˜åŒ–

1. **WASM ç¼“å­˜**:
   ```typescript
   // ç¼“å­˜ WASM æ¨¡å—åˆ° localStorage
   const cachedWasm = localStorage.getItem("fhe-wasm");
   if (cachedWasm) {
     await initSDK({ wasmModule: cachedWasm });
   }
   ```

2. **å¹¶è¡ŒåŠ å¯†**:
   ```typescript
   // åŒæ—¶åŠ å¯†å¤šä¸ªå€¼
   await Promise.all([
     encryptAsset(balance),
     encryptNFTCount(nftCount),
     encryptAccountAge(age),
   ]);
   ```

---

## 9. éƒ¨ç½²æ–¹æ¡ˆ

### 9.1 Testnet éƒ¨ç½²æ­¥éª¤

```bash
# 1. å®‰è£…ä¾èµ–
pnpm install

# 2. é…ç½®ç¯å¢ƒå˜é‡
cp .env.example .env
# ç¼–è¾‘ .env:
# PRIVATE_KEY=your_private_key
# SEPOLIA_RPC_URL=https://api.zan.top/eth-sepolia

# 3. ç¼–è¯‘åˆçº¦
npx hardhat compile

# 4. éƒ¨ç½²è„šæœ¬
npx hardhat run scripts/deploy.ts --network sepolia

# 5. éªŒè¯åˆçº¦
npx hardhat verify --network sepolia <CONTRACT_ADDRESS> <CONSTRUCTOR_ARGS>
```

### 9.2 åˆçº¦éƒ¨ç½²é¡ºåº

```
1. ReputationScore.sol
   â†“
2. IdentityProofManager.sol
   â†“
3. VerificationService.sol (ä¼ å…¥ä¸Šé¢ä¸¤ä¸ªåœ°å€)
   â†“
4. CredentialNFT.sol
   â†“
5. è®¾ç½®æƒé™: setIssuer(VerificationService åœ°å€)
```

### 9.3 å‰ç«¯éƒ¨ç½²

```bash
# 1. é…ç½®åˆçº¦åœ°å€
# contracts/deployedContracts.ts
export const deployedContracts = {
  11155111: { // Sepolia
    IdentityProofManager: { address: "0x...", abi: [...] },
    ReputationScore: { address: "0x...", abi: [...] },
    VerificationService: { address: "0x...", abi: [...] },
    CredentialNFT: { address: "0x...", abi: [...] },
  }
};

# 2. æ„å»ºå‰ç«¯
pnpm build

# 3. éƒ¨ç½²åˆ° Vercel
vercel --prod
```

---

## 10. ç›‘æ§ä¸è¿ç»´

### 10.1 å…³é”®æŒ‡æ ‡ç›‘æ§

1. **åˆçº¦äº‹ä»¶ç›‘æ§**:
   - `IdentityRegistered`: æ–°ç”¨æˆ·æ³¨å†Œæ•°
   - `VerificationCompleted`: éªŒè¯å®Œæˆç‡
   - `ScoreChanged`: å£°èª‰å˜åŠ¨è¶‹åŠ¿

2. **Oracle å¥åº·æ£€æŸ¥**:
   - å›è°ƒå»¶è¿Ÿæ—¶é—´
   - å¤±è´¥ç‡ç»Ÿè®¡

3. **å‰ç«¯æ€§èƒ½**:
   - åŠ å¯†è€—æ—¶ï¼ˆç›®æ ‡ < 5 ç§’ï¼‰
   - é¡µé¢åŠ è½½æ—¶é—´

### 10.2 é”™è¯¯å¤„ç†

```typescript
// å‰ç«¯ç»Ÿä¸€é”™è¯¯å¤„ç†
try {
  await encryptAndSubmit(userData);
} catch (error) {
  if (error.code === "ACTION_REJECTED") {
    toast.error("User cancelled transaction");
  } else if (error.message.includes("Gateway")) {
    toast.error("FHE Gateway connection failed");
    // é‡è¯•é€»è¾‘...
  } else {
    Sentry.captureException(error);
    toast.error("Unknown error occurred");
  }
}
```

---

## 11. æŠ€æœ¯é£é™©ä¸åº”å¯¹

| é£é™© | æ¦‚ç‡ | å½±å“ | åº”å¯¹æªæ–½ |
|-----|------|------|---------|
| FHE è®¡ç®—æ—¶é—´è¿‡é•¿ | ä¸­ | é«˜ | 1ï¸âƒ£ ä¼˜åŒ–ç®—æ³•<br>2ï¸âƒ£ å±•ç¤ºè¿›åº¦æ¡<br>3ï¸âƒ£ åå°å¤„ç† |
| Oracle å›è°ƒå¤±è´¥ | ä½ | é«˜ | 1ï¸âƒ£ å®ç°é‡è¯•æœºåˆ¶<br>2ï¸âƒ£ è¶…æ—¶æé†’<br>3ï¸âƒ£ å¤‡ç”¨æ–¹æ¡ˆ |
| æ™ºèƒ½åˆçº¦å‡çº§éœ€æ±‚ | é«˜ | ä¸­ | 1ï¸âƒ£ ä½¿ç”¨ä»£ç†æ¨¡å¼ï¼ˆUUPSï¼‰<br>2ï¸âƒ£ é¢„ç•™å‡çº§æ¥å£ |
| WASM æ¨¡å—åŠ è½½å¤±è´¥ | ä½ | ä¸­ | 1ï¸âƒ£ CDN å¤‡ä»½<br>2ï¸âƒ£ é™çº§æç¤º |

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025-10-26
**ä½œè€…**: PrivyRep Team
**å®¡æ ¸çŠ¶æ€**: å¾…å®¡æ ¸
